#! /usr/bin/env python

import sys
import os.path
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import subprocess
import urllib
import json
import ConfigParser
import re
import cli
import tab
import textwrap
import pprint

URL = '/rest/api/latest'
MAXRESULTS = 50

COMP, CREA, DESC, COMMENTS = range(4)

REHEAD = re.compile('^>>> [^/]+/(?P<key>[A-Z]+-\d+) (?P<summary>.*)$')
RETYPE = re.compile('^Type: +(?P<type>\S+) +Status: +(?P<stat>.*)$')
REPRIO = re.compile('^Priority: +(?P<prio>\S+) +Resolution: +(?P<res>.*)$')
RECOMP = re.compile('^Components: +(?P<comp>\S+) +Versions: +(?P<ver>.*)$')
REMORE = re.compile('^ +(?P<comp>\S+) + +(?P<ver>.*)$')
RECREA = re.compile('^Created: +(?P<crea>\S+) +Security: +(?P<sec>.*)$')
REUPDA = re.compile('^Updated: +(?P<upda>\S+) +Assignee: +(?P<asn>.*)$')
RERESO = re.compile('^Resolved: +(?P<reso>\S+) +Reporter: +(?P<rep>.*)$')

class Gira(cli.Cli):
    def __init__(self, server, project):
        cli.Cli.__init__(self, history=True)

        self.server = server
        self.project = project
        self.prompt = (project if project else 'gira') + '% '
        self.wrapper = textwrap.TextWrapper(width=80)

        # Configuration
        self.cfg = ConfigParser.SafeConfigParser()
        self.cfg.read(self.directory + '/gira.cfg')

        # Get a new cookie if needs be
        self.cookiepath = self.directory + '/cookie'
        if not os.path.exists(os.path.expanduser(self.cookiepath)):
            self.getcookie()

        # Arguments
        self.versionsparser.add_argument('-p', '--project')

        self.componentsparser.add_argument('-p', '--project')

        self.issuesparser.add_argument('-p', '--project')
        self.issuesparser.add_argument('-c', '--component')
        self.issuesparser.add_argument('-v', '--version', nargs='+')
        self.issuesparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.searchparser.add_argument('jql', nargs='+')
        self.searchparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.useparser.add_argument('project')

        self.issueparser.add_argument('key', nargs='+')
        self.issueparser.add_argument('-e', '--edit', action='store_true')

        self.debugparser.add_argument('resource')

        # Sink for curl
        self.null = open(os.devnull, 'w')

    def getcookie(self):
        subprocess.call(['get-cookie', '-u',
                         self.server + '/login', '-o', self.cookiepath])

    def curl(self, res, data=None):
        def curl():
            # Assemble arguments
            args = ['curl', '-b', self.cookiepath]
            if data:
                # str(data) not good enough because JIRA is picky on which
                # quotes to use, and json does it right
                args += ['-X', 'PUT', '-d', json.dumps(data), '-H',
                         'Content-Type: application/json']
            args += [url]

            # Run curl
            proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                    stderr=self.null)
            out, _ = proc.communicate()
            if out: # PUT returns empty string
                return json.loads(out)

        # Prepare
        url = self.server + URL + res

        # Run curl and ask for a cookie if needs be
        try:
            jsonout = curl()
        except ValueError:
            self.getcookie()
            jsonout = curl()

        return jsonout

    def run_versions(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            versions = [ver['name'] for ver in self.curl(res)['versions']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            for version in sorted(versions):
                print >> fhl, version

    def issues(self, query, maxresults):
        rows = [["KEY",
                 "ASSIGNEE",
                 "REPORTER",
                 "COMPONENTS",
                 "VERSIONS",
                 "STATUS",
                 "SUMMARY",
                ]]
        try:
            result = self.search(query, maxresults)
            for issue in result['issues']:
                # Fields
                fields = issue['fields']

                asn = fields['assignee']
                asn = self.nickname(asn['displayName']) if asn else ''

                components = ' '.join([com['name']
                                       for com in fields['components']])

                versions = ' '.join([ver['name']
                                     for ver in fields['fixVersions']])

                rep = fields['reporter']
                rep = self.nickname(rep['displayName']) if rep else ''

                status = fields['status']['name']

                summary = fields['summary']

                # Add row
                rows.append([issue['key'],
                             asn,
                             rep,
                             components,
                             versions,
                             status,
                             summary.strip(),
                            ])
            self.tempreset()
            for fhl in sys.stdout, self.temp:
                tab.tab(rows, spacing=2,
                        maxw=[None, None, None, 5, 8, 6, 26], fhl=fhl)
        except KeyError:
            # No matching issue
            for msg in result['errorMessages']:
                print >> sys.stderr, self.wrapper.fill(msg)

    def run_issues(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Get issues from version
        query = 'project = %s' % \
            (args.project if args.project else self.project)
        query += ' AND component = ' + args.component if args.component else ''
        query += ' AND fixVersion = "%s"' % \
            ' '.join(args.version) if args.version else ''

        self.issues(query, args.maxresults)

    def nickname(self, name):
        try:
            return self.cfg.get('nicknames', name)
        except ConfigParser.NoOptionError:
            return name

    def search(self, jql, maxresults=50):
        return self.curl('/search?jql=%s&maxResults=%d' % \
                         (urllib.quote(jql), maxresults))

    def run_components(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            components = [comp['name'] for comp in self.curl(res)['components']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            for component in sorted(components):
                print >> fhl, component

    def run_search(self, args):
        jql = ['"%s"' % word if ' ' in word else word for word in args.jql]
        self.issues(' '.join(jql), args.maxresults)

    def run_projects(self, args):
        projects = [[prj['name'], prj['key']] for prj in self.curl('/project')]
        projects.insert(0, ["PROJECT", "KEY"])
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            tab.tab(projects, fhl=fhl)

    def run_use(self, args):
        for project in self.curl('/project'):
            if args.project in (project['name'], project['key']):
                self.project = project['key']
                self.prompt = self.project + '% '
                break
        else:
            print >> sys.stderr, args.project + ": No such project"

    def run_foo(self, args):
        subprocess.call(['curl', '-b', self.cookiepath, url])

    def run_issue(self, args):
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            for key in args.key:
                issue = self.curl('/issue/' + key)
                fields = issue['fields']

                # Header
                print >> fhl, ">>> %s/%s %s" % (fields['project']['name'],
                                                issue['key'],
                                                fields['summary'])

                # Type and status
                fmt = "Type:       {0:15} Status:     {1}"
                print >> fhl, fmt.format(fields['issuetype']['name'],
                                         fields['status']['name'])

                # Priority and resolution
                resolution = fields['resolution']
                fmt = "Priority:   {0:15} Resolution: {1}"
                print >> fhl, fmt.format(fields['priority']['name'],
                                         resolution['name']
                                         if resolution else '')

                # Components and versions
                compvers = enumerate(zip(fields['components'],
                                         fields['fixVersions']))
                for i, (component, version) in compvers:
                    if i == 0:
                        fmt = "Components: {0:15} Versions:   {1}"
                    else:
                        fmt = "            {0:15}             {1}"
                    print >> fhl, fmt.format(component['name'], version['name'])

                # Creation date and security
                fmt =  "Created:    {0:15} Security:   {1}"
                print >> fhl, fmt.format(fields['created'][:10],
                                         fields['security']['name'])

                # Update date and assignee
                asn = fields['assignee']
                asn = self.nickname(asn['displayName']) if asn else ''
                fmt =  "Updated:    {0:15} Assignee:   {1}"
                print >> fhl, fmt.format(fields['updated'][:10], asn)

                # Resolution date and reporter
                resdate = fields['resolutiondate']
                fmt =  "Resolved:   {0:15} Reporter:   {1}"
                print >> fhl, \
                    fmt.format(resdate[:10] if resdate else '',
                               self.nickname(fields['reporter']['displayName']))
                print >> fhl

                # Description
                print >> fhl, "Description:"
                if fields['description']:
                    try:
                        print >> fhl, fields['description'].replace('\r', '')
                    except UnicodeEncodeError:
                        # FIXME
                        print >> fhl, "Gira can't handle Unicode for now"

                # Comments
                if fields['comment']['comments']:
                    print >> fhl
                    print >> fhl, "Comments:"
                    print >> fhl
                    for i, comment in enumerate(fields['comment']['comments']):
                        print >> fhl, '%s, %s:' % \
                            (self.nickname(comment['author']['displayName']),
                             comment['updated'][:10])
                        try:
                            print >> fhl, comment['body'].replace('\r', '')
                        except UnicodeEncodeError:
                            # FIXME
                            print >> fhl, "Gira can't handle Unicode for now"
                        if i < fields['comment']['total'] - 1:
                            print >> fhl

                # Footer
                print >> fhl, "<<< %s/%s %s" % (fields['project']['name'],
                                                issue['key'],
                                                fields['summary'])
                print >> fhl

        if args.edit:
            # Open page file in Vim
            self.temp.flush()
            subprocess.call(['vim', '-S', self.directory + '/vimrc',
                             self.temp.name])

            # Parse date from page file
            temp = open(self.temp.name)
            data = self.parse(temp)
            temp.close()
            pprint.pprint(data)
            # out = self.curl('/issue/' + args.key[0], data)
            # if out:
            #     for error in out['errors']:
            #         msg = '%s: %s' % (error, out['errors'][error])
            #         print >> sys.stderr, self.wrapper.fill(msg)

    def parse(self, temp):
        data = {'fields': {}}

        for line in temp:
            line = line[:-1]

            if not line: continue

            match = REHEAD.match(line)
            if match:
                key = match.group('key')
                data['fields']['summary'] = match.group('summary')
                continue

            match = RETYPE.match(line)
            if match:
                data['fields']['issuetype'] = {'name': match.group('type')}
                # data['transition'] = {'name': match.group('stat')}
                continue

            match = REPRIO.match(line)
            if match:
                data['fields']['priority'] = {'name': match.group('prio')}
                # data['fields']['resolution'] = {'name': match.group('res')}
                continue

            match = RECOMP.match(line)
            if match:
                state = COMP
                data['fields']['components'] = [{'name': match.group('comp')}]
                data['fields']['fixVersions'] = [{'name': match.group('ver')}]
                continue

            match = RECREA.match(line)
            if match:
                state = CREA # Just leave components and versions
                # Let's not touch dates for now
                data['fields']['security'] = {'name': match.group('sec')}
                continue

            match = REUPDA.match(line)
            if match:
                # Let's not touch dates for now
                data['fields']['assignee'] = {'name': match.group('asn')}
                continue

            match = RERESO.match(line)
            if match:
                # Let's not touch dates for now
                data['fields']['reporter'] = {'name': match.group('rep')}
                continue

            if line == 'Description:':
                data['fields']['description'] = ''
                state = DESC
                continue

            if line == 'Comments:':
                state = COMMENTS
                continue

            if line[:4] == '<<< ':
                break

            if state == COMP:
                match = REMORE.match(line)
                if match:
                    comp = {'name': match.group('comp')}
                    data['fields']['components'].append(comp)

                    ver = {'name': match.group('ver')}
                    data['fields']['fixVersions'].append(ver)
                    continue
                else:
                    break

            if state == DESC:
                data['fields']['description'] += line
                continue

        return data

    def run_debug(self, args):
        jsonoutput = self.curl(args.resource)
        self.tempreset()
        self.temp.write(pprint.pformat(jsonoutput))
        pprint.pprint(jsonoutput)

def main():
    # Arguments
    p = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    p.add_argument('-s', '--server', default='https://example.net/jira')
    p.add_argument('project', nargs='?')
    args = p.parse_args()

    # CLI
    Gira(args.server, args.project).loop()

if __name__ == '__main__':
    main()
