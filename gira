#! /usr/bin/env python
# coding=utf-8

'''JIRA CLI'''

import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import os.path
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import subprocess
import urllib
import json
import ConfigParser
import re
import textwrap
import itertools
import cli
import tab
import pprint

URL = '/rest/api/latest'
MAXRESULTS = 50
WIDTH = 20

COMP, DESC, OLDCOMM, COMM = range(4)
NONE, VERSION, COMPONENT = range(3) # Grouping

# Fields
REHEAD = re.compile(r'^>>> [^/]+/(?P<key>(?P<proj>[A-Z]+)-\S+) (?P<summ>.*)$')
REFOOT = re.compile(r'^<<< [^/]+/[A-Z]+-\S+ .*$')
RETYPE = re.compile(r'^Type: +(?P<type>.+) +Status: +(?P<stat>.*?)(?: # .*)?$')
REPRIO = re.compile(r'^Priority: +(?P<prio>.+) +Resolution: +(?P<res>.*)$')
RECOMP = re.compile(r'^(Component: +(?P<comp>.+?))?( +Version: +(?P<ver>.+))?$')
RECREA = re.compile(r'^Created: +(?P<crea>.+) +Security: +(?P<sec>.*)$')
REUPDA = re.compile(r'^Updated: +(?P<upda>.+) +Assignee: +(?P<asn>.*)$')
RERESO = re.compile(r'^Resolved: +(?P<reso>.+) +Reporter: +(?P<rep>.*)$')
RECOMM = re.compile(r'^Comment from \w+, \S+:$')

# Index
REISSU = re.compile(r'^(?:(?:└|├)─>)?(?P<key>[A-Z]+-\d+) +.*$')
REGROU = re.compile(r'^#\s+(?P<grouping>.*)$')
REBLAN = re.compile(r'^\s*$')

def row(issues, key, fields, child=''):
    '''Return row of issue field values'''

    values = [child + key]
    for field in fields:
        if isinstance(issues[key][field], list):
            values.append(' ,'.join(issues[key][field]))
        else:
            values.append(issues[key][field])

    return values

def subset(needle, haystack):
    '''Return whether needle is a subset of haystack'''

    if isinstance(needle, list) and isinstance(haystack, list):
        for item0, item1 in itertools.izip_longest(needle, haystack):
            if not subset(item0, item1):
                return False
    elif isinstance(needle, dict) and isinstance(haystack, dict):
        for item in needle:
            if not subset(needle[item], haystack[item]):
                return False
    elif isinstance(needle, str) and isinstance(haystack, unicode):
        return needle.replace('\r', '') == haystack.replace('\r', '')
    else:
        return needle == haystack

    return True

def parseissue(temp):
    '''Parse issue form'''

    # A list of (key, {}) rather than a dictionary keyed on the issue
    # key so we can issues with the same key, as when we create many in
    # one go (e.g. literally 'AA-???').
    issues = [] 

    for line in temp:
        # Parse line
        match = REHEAD.match(line[:-1])
        if match:
            issue = {'fields': {}, 'comment': '', 'comments': [],
                     'transition': {}}
            fields = issue['fields']

            key = match.group('key')
            fields['project'] = {'key': match.group('proj')}
            summary = match.group('summ')

            issues.append((key, issue))
            fields['summary'] = summary
            state = None
            continue

        match = RETYPE.match(line[:-1])
        if match:
            fields['issuetype'] = {'name': match.group('type').strip()}
            issue['transition'] = match.group('stat')
            continue

        match = REPRIO.match(line[:-1])
        if match:
            fields['priority'] = {'name': match.group('prio').strip()}
            continue

        match = RECOMP.match(line[:-1])
        if match and line[:-1]: # But don't eat empty lines
            component = match.group('comp')
            if component:
                if 'components' in fields:
                    components = fields['components']
                    components.append({'name': component.strip()})
                else:
                    fields['components'] = [{'name': component.strip()}]

            version = match.group('ver')
            if version:
                if 'fixVersions' in fields:
                    versions = fields['fixVersions']
                    versions.append({'name': version.strip()})
                else:
                    fields['fixVersions'] = \
                        [{'name': version.strip()}]
            continue

        match = RECREA.match(line[:-1])
        if match:
            # Let's not touch dates for now
            fields['security'] = {'name': match.group('sec').strip()}
            continue

        match = REUPDA.match(line[:-1])
        if match:
            # Let's not touch dates for now
            asn = match.group('asn').strip()
            fields['assignee'] = {'name': asn} if asn else None
            continue

        match = RERESO.match(line[:-1])
        if match:
            # Let's not touch dates for now
            rep = match.group('rep').strip()
            fields['reporter'] = {'name': rep} if rep else None
            continue

        if line[:-1] == 'Description:':
            fields['description'] = ''
            state = DESC
            continue

        if RECOMM.match(line[:-1]):
            state = OLDCOMM

            # Strip last old comment since we know we won't have another one
            if issue['comments']:
                issue['comments'][-1]['body'] = \
                    issue['comments'][-1]['body'][:-2]

            issue['comments'].append({'body': ''})
            continue

        if line[:-1] == 'New Comment?':
            if 'description' in fields:
                fields['description'] = fields['description'][:-2]

            # Strip last old comment since we know we won't have another one
            if issue['comments']:
                issue['comments'][-1]['body'] = \
                    issue['comments'][-1]['body'][:-2]

            state = COMM
            continue

        if REFOOT.match(line[:-1]):
            issue['comment'] = issue['comment'].strip()
            state = None
            continue

        # Handle state
        if state == DESC:
            fields['description'] += line
        elif state == COMM:
            issue['comment'] += line
        elif state == OLDCOMM:
            issue['comments'][-1]['body'] += line

    return issues

def parseissues(temp, grouping):
    '''Parse issue index'''

    issues = {}
    groups = []
    for line in temp:
        # Is it an issue?
        match = REISSU.match(line)
        if match:
            issues[match.group('key')] = {grouping: groups}

        # Is it a header?
        match = REGROU.match(line)
        if match:
            groups.append(match.group('grouping'))

        # Is it a blank line?
        if REBLAN.match(line):
            groups = []

    return issues

class Gira(cli.Cli):
    '''Gira CLI class'''

    def __init__(self, server, project):
        '''Initialise parser and get cookie'''

        cli.Cli.__init__(self, history=True)

        self.server = server
        self.project = project
        self.prompt = (project if project else 'gira') + '% '
        self.wrapper = textwrap.TextWrapper(width=80)

        # Configuration
        self.cfg = ConfigParser.SafeConfigParser()
        self.cfg.read(self.directory + '/gira.cfg')

        # Get a new cookie if needs be
        self.cookiepath = self.directory + '/cookie'
        if not os.path.exists(os.path.expanduser(self.cookiepath)):
            self.getcookie()

        # Arguments
        self.versionsparser.add_argument('-p', '--project')

        self.componentsparser.add_argument('-p', '--project')

        self.issuesparser.add_argument('-p', '--project')
        self.issuesparser.add_argument('-c', '--component')
        self.issuesparser.add_argument('-g', '--group',
                                       choices=['versions', 'components'])
        self.issuesparser.add_argument('-v', '--version', nargs='+')
        self.issuesparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.searchparser.add_argument('jql', nargs='+')
        self.searchparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.useparser.add_argument('project')

        self.issueparser.add_argument('key', nargs='+')

        self.debugparser.add_argument('resource')

        # Sink for curl
        self.null = open(os.devnull, 'w')

    def getcookie(self):
        '''Get cookie'''

        print "Getting a fresh cookie... ",
        sys.stdout.flush()
        subprocess.call(['get-cookie', '-u',
                         self.server + '/login', '-o', self.cookiepath])
        print "Done."

    def curl(self, res, method=None, data=None):
        '''Prepare, run curl and manage its output'''

        def curl():
            '''Run curl'''

            # Assemble arguments
            args = ['curl', '-b', self.cookiepath]
            if method and data:
                # str(data) not good enough because JIRA is picky on which
                # quotes to use, and json does it right
                args += ['-X', method, '-d', json.dumps(data), '-H',
                         'Content-Type: application/json']
            args += [url]

            # Run curl
            proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                    stderr=self.null)
            out, _ = proc.communicate()
            if out: # PUT returns empty string
                return json.loads(out)

        # Prepare
        url = self.server + URL + res

        # Run curl and ask for a cookie if needs be
        try:
            jsonout = curl()
        except ValueError:
            self.getcookie()
            jsonout = curl()

        # Report errors
        if jsonout and 'errors' in jsonout:
            for error in jsonout['errors']:
                msg = '%s: %s' % (error, jsonout['errors'][error])
                print >> sys.stderr, self.wrapper.fill(msg)

        return jsonout

    def run_versions(self, args):
        '''Run versions command'''

        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            versions = [ver['name'] for ver in self.curl(res)['versions']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        tempfhl = open(self.temp, 'w')
        for fhl in sys.stdout, tempfhl:
            for version in sorted(versions):
                print >> fhl, version
        tempfhl.close()

    def issues(self, query, group, maxresults):
        '''Query issues and organise their fields'''

        try:
            # Collect issues and their relationships
            result = self.search(query, maxresults)
        except KeyError:
            # No matching issue
            for msg in result['errorMessages']:
                print >> sys.stderr, self.wrapper.fill(msg)
            return

        if group == 'versions':
            versions = {}
        elif group == 'components':
            components = {}
        issues = {} # Need this structure anyway to subset later on

        for issue in result['issues']:
            # Key
            iss = {}

            # Fields
            fields = issue['fields']

            iss['asn'] = fields['assignee']['name'] \
                if fields['assignee'] else ''

            iss['components'] = [com['name'] for com in fields['components']]

            iss['versions'] = [ver['name'] for ver in fields['fixVersions']]

            iss['rep'] = fields['reporter']['name'] \
                if fields['reporter'] else ''

            iss['status'] = fields['status']['name']

            iss['summary'] = fields['summary'].strip()

            iss['subtasks'] = [subtask['key'] for subtask in fields['subtasks']]

            iss['parent'] = fields['parent'] if 'parent' in fields else None

            if group == 'versions':
                versstr = repr(iss['versions'])
                if versstr in versions:
                    versions[versstr]['issues'][issue['key']] = iss
                else:
                    versions[versstr] = {'versions': iss['versions'],
                                         'issues': {issue['key']: iss}}
            elif group == 'components':
                compstr = repr(iss['components'])
                if compstr in components:
                    components[compstr]['issues'][issue['key']] = iss
                else:
                    components[compstr] = {'components': iss['components'],
                                           'issues': {issue['key']: iss}}
            issues[issue['key']] = iss

        # Report
        tempfhl = open(self.temp, 'w')

        def mkgroup(heading, fields, grouping, group):
            '''Print tables for group'''

            for key in group:
                # Create new table
                rows = [heading]

                # Write header
                for grp in group[key][grouping]:
                    print >> tempfhl, '# ' + grp

                # Write table
                table(rows, group[key]['issues'], fields)
                print >> tempfhl

        def table(rows, issues, fields):
            '''Print table'''

            # Arrange issues for table
            for key in issues:
                issue = issues[key]
                subtasks = issue['subtasks']
                if not issue['parent'] or issue['parent']['key'] not in issues:
                    # Add row
                    rows.append(row(issues, key, fields))

                    if subtasks:
                        # Add subtasks
                        for subtask in subtasks[:-1]:
                            if subtask in issues:
                                rows.append(row(issues, subtask, fields, '├─>'))
                        if subtasks[-1] in issues:
                            rows.append(row(issues, subtasks[-1],
                                            fields, '└─>'))

            # Print table
            tab.tab(rows, spacing=2,
                    maxw=[None, None, None, 5, 8, 6, 26], fhl=tempfhl)

        if group == 'versions':
            mkgroup(["KEY", "ASSIGNEE", "REPORTER", "COMPONENTS",
                     "VERSIONS", "STATUS", "SUMMARY"],
                    ['asn', 'rep', 'components', 'status', 'summary'],
                    group, versions)
        elif group == 'components':
            mkgroup(["KEY", "ASSIGNEE", "REPORTER", "VERSIONS",
                     "STATUS", "SUMMARY"],
                    ['asn', 'rep', 'versions', 'status', 'summary'],
                    group, components)
        else:
            rows = [["KEY", "ASSIGNEE", "REPORTER", "COMPONENTS",
                     "VERSIONS", "STATUS", "SUMMARY"]]
            table(rows, issues, ['asn', 'rep', 'components',
                                 'versions', 'status', 'summary'])

        tempfhl.close()

        return issues

    def run_issues(self, args):
        '''Run issues command'''

        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Get issues from version
        query = 'project = %s' % \
            (args.project if args.project else self.project)
        query += ' AND component = "%s"' % \
            args.component if args.component else ''
        query += ' AND fixVersion = "%s"' % \
            ' '.join(args.version) if args.version else ''

        issues = self.issues(query, args.group, args.maxresults)

        # Open page file in Vim
        subprocess.call(['vim', '-S', self.directory + '/issues.vimrc',
                         self.temp])
        self.wintitle()

        # Only update groups (for now)
        if args.group:
            # Parse data from issues file
            tempvim = open(self.temp)
            issuesedit = parseissues(tempvim, args.group)
            tempvim.close()

            # Update issues
            for key in issuesedit:
                if not subset(issuesedit[key], issues[key]):
                    groups = [{'name': group} for group in
                              issuesedit[key][args.group]]
                    fields = {'fields': {args.group
                                         if args.group != 'versions'
                                         else 'fixVersions': groups}}
                    self.curl('/issue/' + key, 'PUT', fields)

    def search(self, jql, maxresults=50):
        '''Run search query'''

        return self.curl('/search?jql=%s&maxResults=%d' % \
                         (urllib.quote(jql), maxresults))

    def run_components(self, args):
        '''Run components command'''

        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            components = [comp['name'] for comp in self.curl(res)['components']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        tempfhl = open(self.temp, 'w')
        for fhl in sys.stdout, tempfhl:
            for component in sorted(components):
                print >> fhl, component
        tempfhl.close()

    def run_search(self, args):
        '''Run search command'''

        jql = ['"%s"' % word if ' ' in word else word for word in args.jql]
        self.issues(' '.join(jql), None, args.maxresults)

    def run_projects(self, _):
        '''Run projects command'''

        projects = [[prj['name'], prj['key']] for prj in self.curl('/project')]
        projects.insert(0, ["PROJECT", "KEY"])
        tempfhl = open(self.temp, 'w')
        for fhl in sys.stdout, tempfhl:
            tab.tab(projects, fhl=fhl)
        tempfhl.close()

    def run_use(self, args):
        '''Run use command'''

        for project in self.curl('/project'):
            if args.project in (project['name'], project['key']):
                self.project = project['key']
                self.prompt = self.project + '% '
                break
        else:
            print >> sys.stderr, args.project + ": No such project"

    def run_issue(self, args):
        '''Run issue command'''

        issues = {}
        for key in args.key:
            issues[key] = self.curl('/issue/%s?expand=transitions' % key)
            self.form(issues[key], False)

        # Open page file in Vim
        subprocess.call(['vim', '-S', self.directory + '/issue.vimrc',
                         self.temp])
        self.wintitle()

        # Parse data from issue file
        tempvim = open(self.temp)
        issuesedit = parseissue(tempvim)
        tempvim.close()

        for key, fields in issuesedit:
            # Update fields
            if not subset(fields['fields'], issues[key]['fields']):
                self.curl('/issue/' + key, 'PUT', {'fields': fields['fields']})

            # Add comment
            comment = fields['comment']
            if comment:
                self.curl('/issue/%s/comment' % key, 'POST', {'body': comment})

            # Edit comments
            comments = issues[key]['fields']['comment']['comments']
            for i, comment in enumerate(fields['comments']):
                if not subset(comment, comments[i]):
                    cid = comments[i]['id']
                    self.curl('/issue/%s/comment/%s' % (key, cid),
                              'PUT', comment)

            # Perform transition
            for transition in issues[key]['transitions']:
                # No real need to check if any change is needed since
                # states and transitions have different names even if
                # they relate to each other and this will cause this
                # test to fail:
                if fields['transition'] == transition['name']:
                    self.curl('/issue/%s/transitions' % key, 'POST',
                              {'transition': transition['id']})
                    break

    def form(self, issue, new):
        '''Print issue form'''

        fields = issue['fields']

        fhl = open(self.temp, 'w')

        # Header
        print >> fhl, ">>> %s/%s %s" % (fields['project']['name'],
                                        issue['key'],
                                        fields['summary'])

        # Type and status
        if new:
            fmt = "Type:       {0:%d} Status:     {1}" % WIDTH
            print >> fhl, fmt.format(fields['issuetype']['name'],
                                     fields['status']['name'])
        else:
            fmt = "Type:       {0:%d} Status:     {1} # {2}" % WIDTH
            print >> fhl, fmt.format(fields['issuetype']['name'],
                                     fields['status']['name'],
                                     ', '.join([trans['name']
                                                for trans
                                                in issue['transitions']]))

        # Priority and resolution
        priority = fields['priority']
        resolution = fields['resolution']
        fmt = "Priority:   {0:%d} Resolution: {1}" % WIDTH
        print >> fhl, fmt.format(priority['name'] if priority else '',
                                 resolution['name'] if resolution else '')

        # Components and versions
        for component, version in itertools.izip_longest(fields['components'],
                                                         fields['fixVersions']):
            if component and version:
                fmt = "Component:  {0:%d} Version:    {1}" % WIDTH
                values = (component['name'], version['name'])
            elif component:
                fmt = "Component:  {0:%d}" % WIDTH
                values = (component['name'],)
            elif version:
                values = ('', version['name'],)
                fmt = "            {0:%d} Version:    {1}" % WIDTH
            print >> fhl, fmt.format(*values)

        # Creation date and security
        fmt =  "Created:    {0:%d} Security:   {1}" % WIDTH
        print >> fhl, fmt.format(fields['created'][:10],
                                 fields['security']['name'])

        # Update date and assignee
        asn = fields['assignee']
        asn = asn['name'] if asn else ''
        fmt =  "Updated:    {0:%d} Assignee:   {1}" % WIDTH
        print >> fhl, fmt.format(fields['updated'][:10], asn)

        # Resolution date and reporter
        resdate = fields['resolutiondate']
        fmt =  "Resolved:   {0:%d} Reporter:   {1}" % WIDTH
        print >> fhl, \
            fmt.format(resdate[:10] if resdate else '',
                       fields['reporter']['name'])

        # Description
        print >> fhl
        print >> fhl, "Description:"
        if fields['description']:
            print >> fhl, fields['description'].replace('\r', '')

        # Comments
        if fields['comment']['comments']:
            for comment in fields['comment']['comments']:
                print >> fhl
                print >> fhl, "Comment from %s, %s:" % \
                    (comment['author']['name'], comment['updated'][:10])
                print >> fhl, comment['body'].replace('\r', '')

        if not new:
            print >> fhl
            print >> fhl, "New Comment?"
            print >> fhl

        # Footer
        print >> fhl, "<<< %s/%s %s" % (fields['project']['name'],
                                        issue['key'],
                                        fields['summary'])
        print >> fhl
        fhl.close()

    def run_create(self, _):
        '''Run create command'''

        # Write form
        issue = {'fields':
                    {'assignee': {'name': ''},
                     'comment': {'comments': []},
                     'components': [{'name': 'TODO'}], # pylint: disable=fixme
                     'created': 'Now',
                     'description': 'TODO', # pylint: disable=fixme
                     'fixVersions': [{'name': 'TODO'}], # pylint: disable=fixme
                     'issuetype': {'name': 'TODO'}, # pylint: disable=fixme
                     'priority': {'name': 'TODO'}, # pylint: disable=fixme
                     'project': {'name': self.project},
                     'reporter': {'name': os.environ['USER']},
                     'resolution': {'name': ''},
                     'resolutiondate': '',
                     'security': {'name': 'Internal Data'},
                     'status': {'name': 'Open'},
                     'summary': 'TODO', # pylint: disable=fixme
                     'updated': 'Now'},
                 'key': self.project + '-???',
                 'transitions': []}
        self.form(issue, True)

        # Open page file in Vim
        subprocess.call(['vim', '-S', self.directory + '/issue.vimrc',
                         self.temp])
        self.wintitle()

        # Parse date from page file
        tempvim = open(self.temp)
        issuesedit = parseissue(tempvim)
        tempvim.close()

        # Write issue data to JIRA
        for _, fields in issuesedit:
            self.curl('/issue', 'POST', {'fields': fields['fields']})

    def run_debug(self, args):
        '''Run query and print raw result'''

        jsonoutput = self.curl(args.resource)
        tempfhl = open(self.temp, 'w')
        tempfhl.write(pprint.pformat(jsonoutput))
        tempfhl.close()
        pprint.pprint(jsonoutput)

def main():
    '''Main function'''

    # Arguments
    parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument('-s', '--server', default='https://example.net/jira')
    parser.add_argument('project', nargs='?')
    args = parser.parse_args()

    # CLI
    Gira(args.server, args.project).loop()

if __name__ == '__main__':
    main()
