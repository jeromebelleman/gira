#! /usr/bin/env python

import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import os.path
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import subprocess
import urllib
import json
import ConfigParser
import re
import tempfile
import cli
import tab
import textwrap
import pprint

URL = '/rest/api/latest'
MAXRESULTS = 50

COMP, DESC, OLDCOMM, COMM = range(4)

REHEAD = re.compile('^>>> (?P<proj>[^/]+)/(?P<key>[A-Z]+-\d+) (?P<summary>.*)$')
RETYPE = re.compile('^Type: +(?P<type>.+) +Status: +(?P<stat>.*) # .*$')
REPRIO = re.compile('^Priority: +(?P<prio>.+) +Resolution: +(?P<res>.*)$')
RECOMP = re.compile('^Components: +(?P<comp>.+) +Versions: +(?P<ver>.*)$')
REMORE = re.compile('^ +(?P<comp>.+) {5,}(?P<ver>.*)$')
RECREA = re.compile('^Created: +(?P<crea>.+) +Security: +(?P<sec>.*)$')
REUPDA = re.compile('^Updated: +(?P<upda>.+) +Assignee: +(?P<asn>.*)$')
RERESO = re.compile('^Resolved: +(?P<reso>.+) +Reporter: +(?P<rep>.*)$')
RECOMM = re.compile('^Comment from \w+, \S+:$')

class Gira(cli.Cli):
    def __init__(self, server, project):
        cli.Cli.__init__(self, history=True)

        self.server = server
        self.project = project
        self.prompt = (project if project else 'gira') + '% '
        self.wrapper = textwrap.TextWrapper(width=80)

        # Configuration
        self.cfg = ConfigParser.SafeConfigParser()
        self.cfg.read(self.directory + '/gira.cfg')

        # Get a new cookie if needs be
        self.cookiepath = self.directory + '/cookie'
        if not os.path.exists(os.path.expanduser(self.cookiepath)):
            self.getcookie()

        # Arguments
        self.versionsparser.add_argument('-p', '--project')

        self.componentsparser.add_argument('-p', '--project')

        self.issuesparser.add_argument('-p', '--project')
        self.issuesparser.add_argument('-c', '--component')
        self.issuesparser.add_argument('-v', '--version', nargs='+')
        self.issuesparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.searchparser.add_argument('jql', nargs='+')
        self.searchparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.useparser.add_argument('project')

        self.issueparser.add_argument('key', nargs='+')
        self.issueparser.add_argument('-e', '--edit', action='store_true')

        self.debugparser.add_argument('resource')

        # Sink for curl
        self.null = open(os.devnull, 'w')

    def getcookie(self):
        print "Getting a fresh cookie... ",
        sys.stdout.flush()
        subprocess.call(['get-cookie', '-u',
                         self.server + '/login', '-o', self.cookiepath])
        print "Done."

    def curl(self, res, method=None, data=None):
        def curl():
            # Assemble arguments
            args = ['curl', '-b', self.cookiepath]
            if method and data:
                # str(data) not good enough because JIRA is picky on which
                # quotes to use, and json does it right
                args += ['-X', method, '-d', json.dumps(data), '-H',
                         'Content-Type: application/json']
            args += [url]

            # Run curl
            proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                    stderr=self.null)
            out, _ = proc.communicate()
            if out: # PUT returns empty string
                return json.loads(out)

        # Prepare
        url = self.server + URL + res

        # Run curl and ask for a cookie if needs be
        try:
            jsonout = curl()
        except ValueError:
            self.getcookie()
            jsonout = curl()

        return jsonout

    def run_versions(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            versions = [ver['name'] for ver in self.curl(res)['versions']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            for version in sorted(versions):
                print >> fhl, version

    def issues(self, query, maxresults):
        rows = [["KEY",
                 "ASSIGNEE",
                 "REPORTER",
                 "COMPONENTS",
                 "VERSIONS",
                 "STATUS",
                 "SUMMARY",
                ]]
        try:
            result = self.search(query, maxresults)
            for issue in result['issues']:
                # Fields
                fields = issue['fields']

                asn = fields['assignee']
                asn = asn['name'] if asn else ''

                components = ' '.join([com['name']
                                       for com in fields['components']])

                versions = ' '.join([ver['name']
                                     for ver in fields['fixVersions']])

                rep = fields['reporter']
                rep = rep['name'] if rep else ''

                status = fields['status']['name']

                summary = fields['summary']

                # Add row
                rows.append([issue['key'],
                             asn,
                             rep,
                             components,
                             versions,
                             status,
                             summary.strip(),
                            ])
            self.tempreset()
            for fhl in sys.stdout, self.temp:
                tab.tab(rows, spacing=2,
                        maxw=[None, None, None, 5, 8, 6, 26], fhl=fhl)
        except KeyError:
            # No matching issue
            for msg in result['errorMessages']:
                print >> sys.stderr, self.wrapper.fill(msg)

    def run_issues(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Get issues from version
        query = 'project = %s' % \
            (args.project if args.project else self.project)
        query += ' AND component = ' + args.component if args.component else ''
        query += ' AND fixVersion = "%s"' % \
            ' '.join(args.version) if args.version else ''

        self.issues(query, args.maxresults)

    def nickname(self, name):
        try:
            return self.cfg.get('nicknames', name)
        except ConfigParser.NoOptionError:
            return name

    def search(self, jql, maxresults=50):
        return self.curl('/search?jql=%s&maxResults=%d' % \
                         (urllib.quote(jql), maxresults))

    def run_components(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            components = [comp['name'] for comp in self.curl(res)['components']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            for component in sorted(components):
                print >> fhl, component

    def run_search(self, args):
        jql = ['"%s"' % word if ' ' in word else word for word in args.jql]
        self.issues(' '.join(jql), args.maxresults)

    def run_projects(self, args):
        projects = [[prj['name'], prj['key']] for prj in self.curl('/project')]
        projects.insert(0, ["PROJECT", "KEY"])
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            tab.tab(projects, fhl=fhl)

    def run_use(self, args):
        for project in self.curl('/project'):
            if args.project in (project['name'], project['key']):
                self.project = project['key']
                self.prompt = self.project + '% '
                break
        else:
            print >> sys.stderr, args.project + ": No such project"

    def run_issue(self, args):
        self.tempreset()
        temp = tempfile.NamedTemporaryFile(prefix='issue-', dir=self.directory)

        if args.edit:
            fhl = temp
        else:
            fhl = sys.stdout

        for key in args.key:
            issue = self.curl('/issue/%s?expand=transitions' % key)
            fields = issue['fields']
            transs = ['%s (%s)' % (trans['name'], trans['id'])
                      for trans in issue['transitions']]

            # Header
            print >> fhl, ">>> %s/%s %s" % (fields['project']['name'],
                                            issue['key'],
                                            fields['summary'])

            # Type and status
            fmt = "Type:       {0:15} Status:     {1} # {2}"
            print >> fhl, fmt.format(fields['issuetype']['name'],
                                     fields['status']['name'],
                                     ', '.join(transs))

            # Priority and resolution
            resolution = fields['resolution']
            fmt = "Priority:   {0:15} Resolution: {1}"
            print >> fhl, fmt.format(fields['priority']['name'],
                                     resolution['name']
                                     if resolution else '')

            # Components and versions
            compvers = enumerate(zip(fields['components'],
                                     fields['fixVersions']))
            for i, (component, version) in compvers:
                if i == 0:
                    fmt = "Components: {0:15} Versions:   {1}"
                else:
                    fmt = "            {0:15}             {1}"
                print >> fhl, fmt.format(component['name'], version['name'])

            # Creation date and security
            fmt =  "Created:    {0:15} Security:   {1}"
            print >> fhl, fmt.format(fields['created'][:10],
                                     fields['security']['name'])

            # Update date and assignee
            asn = fields['assignee']
            asn = asn['name'] if asn else ''
            fmt =  "Updated:    {0:15} Assignee:   {1}"
            print >> fhl, fmt.format(fields['updated'][:10], asn)

            # Resolution date and reporter
            resdate = fields['resolutiondate']
            fmt =  "Resolved:   {0:15} Reporter:   {1}"
            print >> fhl, \
                fmt.format(resdate[:10] if resdate else '',
                           fields['reporter']['name'])

            # Description
            if fields['description']:
                print >> fhl
                print >> fhl, "Description:"
                print >> fhl, fields['description'].replace('\r', '').strip()

            # Comments
            if fields['comment']['comments']:
                for i, comment in enumerate(fields['comment']['comments']):
                    print >> fhl
                    print >> fhl, "Comment from %s, %s:" % \
                        (comment['author']['name'], comment['updated'][:10])
                    print >> fhl, comment['body'].replace('\r', '').strip()

            if args.edit:
                print >> fhl
                print >> fhl, "New Comment?"
                print >> fhl

            # Footer
            print >> fhl, "<<< %s/%s %s" % (fields['project']['name'],
                                            issue['key'],
                                            fields['summary'])
            print >> fhl

        if args.edit:
            # Open page file in Vim
            temp.flush()
            subprocess.call(['vim', '-S', self.directory + '/vimrc', temp.name])

            # Parse date from page file
            tempvim = open(temp.name)
            issues = self.parse(tempvim)
            tempvim.close()

            for issue in issues:
                # Update fields
                out = self.curl('/issue/' + issue, 'PUT',
                                {'fields': issues[issue]['fields']})
                if out and 'errors' in out:
                    for error in out['errors']:
                        msg = '%s: %s' % (error, out['errors'][error])
                        print >> sys.stderr, self.wrapper.fill(msg)

                # Add comment
                comment = issues[issue]['comment']
                if comment:
                    out = self.curl('/issue/%s/comment' % issue, 'POST',
                                    {'body': comment})
                    if out and 'errors' in out:
                        for error in out['errors']:
                            msg = '%s: %s' % (error, out['errors'][error])
                            print >> sys.stderr, self.wrapper.fill(msg)

                # Perform transition
                transition = issues[issue]['transition']
                if transition and transition['id'].isdigit():
                    out = self.curl('/issue/%s/transitions' % issue, 'POST',
                                    {'transition': transition['id']})
                    if out and 'errors' in out:
                        for error in out['errors']:
                            msg = '%s: %s' % (error, out['errors'][error])
                            print >> sys.stderr, self.wrapper.fill(msg)
        temp.close()

    def parse(self, temp):
        issues = {}

        for line in temp:
            # Parse line
            match = REHEAD.match(line[:-1])
            if match:
                issue = {'fields': {}, 'comment': {}, 'transition': {}}

                key = match.group('key')
                summary = match.group('summary')
                footer = '<<< %s/%s %s' % (match.group('proj'), key, summary)

                issues[key] = issue
                issue['fields']['summary'] = summary
                state = None
                continue

            match = RETYPE.match(line[:-1])
            if match:
                issue['fields']['issuetype'] = \
                    {'name': match.group('type').strip()}
                issue['transition'] = {'id': match.group('stat')}
                continue

            match = REPRIO.match(line[:-1])
            if match:
                issue['fields']['priority'] = \
                    {'name': match.group('prio').strip()}
                continue

            match = RECOMP.match(line[:-1])
            if match:
                issue['fields']['components'] = \
                    [{'name': match.group('comp').strip()}]
                issue['fields']['fixVersions'] = \
                    [{'name': match.group('ver').strip()}]
                state = COMP
                continue

            match = RECREA.match(line[:-1])
            if match:
                # Let's not touch dates for now
                issue['fields']['security'] = \
                    {'name': match.group('sec').strip()}
                continue

            match = REUPDA.match(line[:-1])
            if match:
                # Let's not touch dates for now
                issue['fields']['assignee'] = \
                    {'name': match.group('asn').strip()}
                continue

            match = RERESO.match(line[:-1])
            if match:
                # Let's not touch dates for now
                issue['fields']['reporter'] = \
                    {'name': match.group('rep').strip()}
                continue

            if line[:-1] == 'Description:':
                issue['fields']['description'] = ''
                state = DESC
                continue

            if RECOMM.match(line[:-1]):
                state = OLDCOMM
                continue

            if line[:-1] == 'New Comment?':
                if 'description' in issue['fields']:
                    issue['fields']['description'] = \
                        issue['fields']['description'].strip()

                issue['comment'] = ''
                state = COMM
                continue

            if line[:-1] == footer:
                issue['comment'] = issue['comment'].strip()
                state = None
                continue

            # Handle state
            if state == COMP:
                match = REMORE.match(line[:-1])
                if match:
                    comp = {'name': match.group('comp')}
                    issue['fields']['components'].append(comp)

                    ver = {'name': match.group('ver')}
                    issue['fields']['fixVersions'].append(ver)
                else:
                    state = None
            elif state == DESC:
                issue['fields']['description'] += line
            elif state == COMM:
                issue['comment'] += line

        return issues

    def run_debug(self, args):
        jsonoutput = self.curl(args.resource)
        self.tempreset()
        self.temp.write(pprint.pformat(jsonoutput))
        pprint.pprint(jsonoutput)

def main():
    # Arguments
    p = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    p.add_argument('-s', '--server', default='https://example.net/jira')
    p.add_argument('project', nargs='?')
    args = p.parse_args()

    # CLI
    Gira(args.server, args.project).loop()

if __name__ == '__main__':
    main()
