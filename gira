#! /usr/bin/env python

import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import os.path
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import subprocess
import urllib
import json
import ConfigParser
import re
import tempfile
import textwrap
import itertools
import cli
import tab
import pprint

URL = '/rest/api/latest'
MAXRESULTS = 50
WIDTH = 20

COMP, DESC, OLDCOMM, COMM = range(4)

REHEAD = re.compile('^>>> (?P<proj>[^/]+)/(?P<key>[A-Z]+-\d+) (?P<summary>.*)$')
RETYPE = re.compile('^Type: +(?P<type>.+) +Status: +(?P<stat>.*) # .*$')
REPRIO = re.compile('^Priority: +(?P<prio>.+) +Resolution: +(?P<res>.*)$')
RECOMP = re.compile('^(Component: +(?P<comp>.+?))?( +Version: +(?P<ver>.+))?$')
RECREA = re.compile('^Created: +(?P<crea>.+) +Security: +(?P<sec>.*)$')
REUPDA = re.compile('^Updated: +(?P<upda>.+) +Assignee: +(?P<asn>.*)$')
RERESO = re.compile('^Resolved: +(?P<reso>.+) +Reporter: +(?P<rep>.*)$')
RECOMM = re.compile('^Comment from \w+, \S+:$')

def subset(needle, haystack):
    if isinstance(needle, list) and isinstance(haystack, list):
        for item0, item1 in zip(needle, haystack):
            if not subset(item0, item1):
                return False
    elif isinstance(needle, dict) and isinstance(haystack, dict):
        for item in needle:
            if not subset(needle[item], haystack[item]):
                return False
    elif isinstance(needle, str) and isinstance(haystack, unicode):
        return needle.replace('\r', '') == haystack.replace('\r', '')
    else:
        return needle == haystack

    return True

class Gira(cli.Cli):
    def __init__(self, server, project):
        cli.Cli.__init__(self, history=True)

        self.server = server
        self.project = project
        self.prompt = (project if project else 'gira') + '% '
        self.wrapper = textwrap.TextWrapper(width=80)

        # Configuration
        self.cfg = ConfigParser.SafeConfigParser()
        self.cfg.read(self.directory + '/gira.cfg')

        # Get a new cookie if needs be
        self.cookiepath = self.directory + '/cookie'
        if not os.path.exists(os.path.expanduser(self.cookiepath)):
            self.getcookie()

        # Arguments
        self.versionsparser.add_argument('-p', '--project')

        self.componentsparser.add_argument('-p', '--project')

        self.issuesparser.add_argument('-p', '--project')
        self.issuesparser.add_argument('-c', '--component')
        self.issuesparser.add_argument('-v', '--version', nargs='+')
        self.issuesparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.searchparser.add_argument('jql', nargs='+')
        self.searchparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.useparser.add_argument('project')

        self.issueparser.add_argument('key', nargs='+')
        self.issueparser.add_argument('-e', '--edit', action='store_true')

        self.debugparser.add_argument('resource')

        # Sink for curl
        self.null = open(os.devnull, 'w')

    def getcookie(self):
        print "Getting a fresh cookie... ",
        sys.stdout.flush()
        subprocess.call(['get-cookie', '-u',
                         self.server + '/login', '-o', self.cookiepath])
        print "Done."

    def curl(self, res, method=None, data=None):
        def curl():
            # Assemble arguments
            args = ['curl', '-b', self.cookiepath]
            if method and data:
                # str(data) not good enough because JIRA is picky on which
                # quotes to use, and json does it right
                args += ['-X', method, '-d', json.dumps(data), '-H',
                         'Content-Type: application/json']
            args += [url]

            # Run curl
            proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                    stderr=self.null)
            out, _ = proc.communicate()
            if out: # PUT returns empty string
                return json.loads(out)

        # Prepare
        url = self.server + URL + res

        # Run curl and ask for a cookie if needs be
        try:
            jsonout = curl()
        except ValueError:
            self.getcookie()
            jsonout = curl()

        return jsonout

    def run_versions(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            versions = [ver['name'] for ver in self.curl(res)['versions']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            for version in sorted(versions):
                print >> fhl, version

    def issues(self, query, maxresults):
        rows = [["KEY",
                 "ASSIGNEE",
                 "REPORTER",
                 "COMPONENTS",
                 "VERSIONS",
                 "STATUS",
                 "SUMMARY",
                ]]
        try:
            result = self.search(query, maxresults)
            for issue in result['issues']:
                # Fields
                fields = issue['fields']

                asn = fields['assignee']
                asn = asn['name'] if asn else ''

                components = ' '.join([com['name']
                                       for com in fields['components']])

                versions = ' '.join([ver['name']
                                     for ver in fields['fixVersions']])

                rep = fields['reporter']
                rep = rep['name'] if rep else ''

                status = fields['status']['name']

                summary = fields['summary']

                # Add row
                rows.append([issue['key'],
                             asn,
                             rep,
                             components,
                             versions,
                             status,
                             summary.strip(),
                            ])
            self.tempreset()
            for fhl in sys.stdout, self.temp:
                tab.tab(rows, spacing=2,
                        maxw=[None, None, None, 5, 8, 6, 26], fhl=fhl)
        except KeyError:
            # No matching issue
            for msg in result['errorMessages']:
                print >> sys.stderr, self.wrapper.fill(msg)

    def run_issues(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Get issues from version
        query = 'project = %s' % \
            (args.project if args.project else self.project)
        query += ' AND component = "%s"' % \
            args.component if args.component else ''
        query += ' AND fixVersion = "%s"' % \
            ' '.join(args.version) if args.version else ''

        self.issues(query, args.maxresults)

    def nickname(self, name):
        try:
            return self.cfg.get('nicknames', name)
        except ConfigParser.NoOptionError:
            return name

    def search(self, jql, maxresults=50):
        return self.curl('/search?jql=%s&maxResults=%d' % \
                         (urllib.quote(jql), maxresults))

    def run_components(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            components = [comp['name'] for comp in self.curl(res)['components']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            for component in sorted(components):
                print >> fhl, component

    def run_search(self, args):
        jql = ['"%s"' % word if ' ' in word else word for word in args.jql]
        self.issues(' '.join(jql), args.maxresults)

    def run_projects(self, args):
        projects = [[prj['name'], prj['key']] for prj in self.curl('/project')]
        projects.insert(0, ["PROJECT", "KEY"])
        self.tempreset()
        for fhl in sys.stdout, self.temp:
            tab.tab(projects, fhl=fhl)

    def run_use(self, args):
        for project in self.curl('/project'):
            if args.project in (project['name'], project['key']):
                self.project = project['key']
                self.prompt = self.project + '% '
                break
        else:
            print >> sys.stderr, args.project + ": No such project"

    def run_issue(self, args):
        self.tempreset()
        temp = tempfile.NamedTemporaryFile(prefix='issue-', dir=self.directory)

        if args.edit:
            fhl = temp
        else:
            fhl = sys.stdout

        issues = {}
        for key in args.key:
            issue = self.curl('/issue/%s?expand=transitions' % key)
            issues[key] = issue
            fields = issue['fields']
            transs = [trans['name'] for trans in issue['transitions']]

            # Header
            print >> fhl, ">>> %s/%s %s" % (fields['project']['name'],
                                            issue['key'],
                                            fields['summary'])

            # Type and status
            fmt = "Type:       {0:%d} Status:     {1} # {2}" % WIDTH
            print >> fhl, fmt.format(fields['issuetype']['name'],
                                     fields['status']['name'],
                                     ', '.join(transs))

            # Priority and resolution
            priority = fields['priority']
            resolution = fields['resolution']
            fmt = "Priority:   {0:%d} Resolution: {1}" % WIDTH
            print >> fhl, fmt.format(priority['name'] if priority else '',
                                     resolution['name'] if resolution else '')

            # Components and versions)
            compvers = enumerate(itertools.izip_longest(fields['components'],
                                                        fields['fixVersions']))
            for i, (component, version) in compvers:
                if component and version:
                    fmt = "Component:  {0:%d} Version:    {1}" % WIDTH
                    values = (component['name'], version['name'])
                elif component:
                    fmt = "Component:  {0:%d}" % WIDTH
                    values = (component['name'],)
                elif version:
                    values = ('', version['name'],)
                    fmt = "            {0:%d} Version:    {1}" % WIDTH
                print >> fhl, fmt.format(*values)

            # Creation date and security
            fmt =  "Created:    {0:%d} Security:   {1}" % WIDTH
            print >> fhl, fmt.format(fields['created'][:10],
                                     fields['security']['name'])

            # Update date and assignee
            asn = fields['assignee']
            asn = asn['name'] if asn else ''
            fmt =  "Updated:    {0:%d} Assignee:   {1}" % WIDTH
            print >> fhl, fmt.format(fields['updated'][:10], asn)

            # Resolution date and reporter
            resdate = fields['resolutiondate']
            fmt =  "Resolved:   {0:%d} Reporter:   {1}" % WIDTH
            print >> fhl, \
                fmt.format(resdate[:10] if resdate else '',
                           fields['reporter']['name'])

            # Description
            if fields['description']:
                print >> fhl
                print >> fhl, "Description:"
                print >> fhl, fields['description'].replace('\r', '')

            # Comments
            if fields['comment']['comments']:
                for i, comment in enumerate(fields['comment']['comments']):
                    print >> fhl
                    print >> fhl, "Comment from %s, %s:" % \
                        (comment['author']['name'], comment['updated'][:10])
                    print >> fhl, comment['body'].replace('\r', '')

            if args.edit:
                print >> fhl
                print >> fhl, "New Comment?"
                print >> fhl

            # Footer
            print >> fhl, "<<< %s/%s %s" % (fields['project']['name'],
                                            issue['key'],
                                            fields['summary'])
            print >> fhl

        if args.edit:
            # Open page file in Vim
            temp.flush()
            subprocess.call(['vim', '-S', self.directory + '/vimrc', temp.name])
            self.wintitle()

            # Parse date from page file
            tempvim = open(temp.name)
            issuesedit = self.parse(tempvim)
            tempvim.close()

            for issue in issuesedit:
                # Update fields
                if not subset(issuesedit[issue]['fields'],
                              issues[issue]['fields']):
                    out = self.curl('/issue/' + issue, 'PUT',
                                    {'fields': issuesedit[issue]['fields']})
                    if out and 'errors' in out:
                        for error in out['errors']:
                            msg = '%s: %s' % (error, out['errors'][error])
                            print >> sys.stderr, self.wrapper.fill(msg)

                # Add comment
                comment = issuesedit[issue]['comment']
                if comment:
                    out = self.curl('/issue/%s/comment' % issue, 'POST',
                                    {'body': comment})
                    if out and 'errors' in out:
                        for error in out['errors']:
                            msg = '%s: %s' % (error, out['errors'][error])
                            print >> sys.stderr, self.wrapper.fill(msg)

                # Edit comments
                comments = issues[issue]['fields']['comment']['comments']
                for i, comment in enumerate(issuesedit[issue]['comments']):
                    if not subset(comment, comments[i]):
                        cid = comments[i]['id']
                        out = self.curl('/issue/%s/comment/%s' % (issue, cid),
                                        'PUT', {'body': comment})
                        # FIXME Refactor error printing (maybe in curl() itself)
                        if out and 'errors' in out:
                            for error in out['errors']:
                                msg = '%s: %s' % (error, out['errors'][error])
                                print >> sys.stderr, self.wrapper.fill(msg)

                # Perform transition
                for transition in issues[issue]['transitions']:
                    # No real need to check if any change is needed since
                    # states and transitions have different names even if
                    # they relate to each other and this will cause this
                    # test to fail:
                    if issuesedit[issue]['transition'] == transition['name']:
                        out = self.curl('/issue/%s/transitions' % issue, 'POST',
                                        {'transition': transition['id']})
                        if out and 'errors' in out:
                            for error in out['errors']:
                                msg = '%s: %s' % (error, out['errors'][error])
                                print >> sys.stderr, self.wrapper.fill(msg)
                        break
        temp.close()

    def parse(self, temp):
        issues = {}

        for line in temp:
            # Parse line
            match = REHEAD.match(line[:-1])
            if match:
                issue = {'fields': {}, 'comment': {}, 'comments': [],
                         'transition': {}}
                fields = issue['fields']

                key = match.group('key')
                summary = match.group('summary')
                footer = '<<< %s/%s %s' % (match.group('proj'), key, summary)

                issues[key] = issue
                fields['summary'] = summary
                state = None
                continue

            match = RETYPE.match(line[:-1])
            if match:
                fields['issuetype'] = {'name': match.group('type').strip()}
                issue['transition'] = match.group('stat')
                continue

            match = REPRIO.match(line[:-1])
            if match:
                fields['priority'] = {'name': match.group('prio').strip()}
                continue

            match = RECOMP.match(line[:-1])
            if match and line[:-1]: # But don't eat empty lines
                component = match.group('comp')
                if component:
                    if 'components' in fields:
                        components = fields['components']
                        components.append({'name': component.strip()})
                    else:
                        fields['components'] = [{'name': component.strip()}]

                version = match.group('ver')
                if version:
                    if 'fixVersions' in fields:
                        versions = fields['fixVersions']
                        versions.append({'name': version.strip()})
                    else:
                        fields['fixVersions'] = \
                            [{'name': version.strip()}]
                continue

            match = RECREA.match(line[:-1])
            if match:
                # Let's not touch dates for now
                fields['security'] = {'name': match.group('sec').strip()}
                continue

            match = REUPDA.match(line[:-1])
            if match:
                # Let's not touch dates for now
                asn = match.group('asn').strip()
                fields['assignee'] = {'name': asn} if asn else None
                continue

            match = RERESO.match(line[:-1])
            if match:
                # Let's not touch dates for now
                rep = match.group('rep').strip()
                fields['reporter'] = {'name': rep} if rep else None
                continue

            if line[:-1] == 'Description:':
                fields['description'] = ''
                state = DESC
                continue

            if RECOMM.match(line[:-1]):
                state = OLDCOMM

                # Strip last old comment since we know we won't have another one
                if issue['comments']:
                    issue['comments'][-1]['body'] = \
                        issue['comments'][-1]['body'][:-2]

                issue['comments'].append({'body': ''})
                continue

            if line[:-1] == 'New Comment?':
                if 'description' in fields:
                    fields['description'] = fields['description'][:-2]

                # Strip last old comment since we know we won't have another one
                if issue['comments']:
                    issue['comments'][-1]['body'] = \
                        issue['comments'][-1]['body'][:-2]

                issue['comment'] = ''
                state = COMM
                continue

            if line[:-1] == footer:
                issue['comment'] = issue['comment'].strip()
                state = None
                continue

            # Handle state
            if state == DESC:
                fields['description'] += line
            elif state == COMM:
                issue['comment'] += line
            elif state == OLDCOMM:
                issue['comments'][-1]['body'] += line

        return issues

    def run_debug(self, args):
        jsonoutput = self.curl(args.resource)
        self.tempreset()
        self.temp.write(pprint.pformat(jsonoutput))
        pprint.pprint(jsonoutput)

def main():
    # Arguments
    p = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    p.add_argument('-s', '--server', default='https://example.net/jira')
    p.add_argument('project', nargs='?')
    args = p.parse_args()

    # CLI
    Gira(args.server, args.project).loop()

if __name__ == '__main__':
    main()
