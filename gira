#! /usr/bin/env python
# coding=utf-8

import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import os.path
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import subprocess
import urllib
import json
import ConfigParser
import re
import tempfile
import textwrap
import itertools
import cli
import tab
import pprint

URL = '/rest/api/latest'
MAXRESULTS = 50
WIDTH = 20

COMP, DESC, OLDCOMM, COMM = range(4)
NONE, VERSION, COMPONENT = range(3) # Grouping

# Fields
REHEAD = re.compile('^>>> (?P<proj>[^/]+)/(?P<key>[A-Z]+-\S+) (?P<summary>.*)$')
REFOOT = re.compile('^<<< [^/]+/[A-Z]+-\S+ .*$')
RETYPE = re.compile('^Type: +(?P<type>.+) +Status: +(?P<stat>.*)(?: # .*)?$')
REPRIO = re.compile('^Priority: +(?P<prio>.+) +Resolution: +(?P<res>.*)$')
RECOMP = re.compile('^(Component: +(?P<comp>.+?))?( +Version: +(?P<ver>.+))?$')
RECREA = re.compile('^Created: +(?P<crea>.+) +Security: +(?P<sec>.*)$')
REUPDA = re.compile('^Updated: +(?P<upda>.+) +Assignee: +(?P<asn>.*)$')
RERESO = re.compile('^Resolved: +(?P<reso>.+) +Reporter: +(?P<rep>.*)$')
RECOMM = re.compile('^Comment from \w+, \S+:$')

# Index
RELINE = re.compile('^(?P<child> +|(?:└|├)─>)?(?P<key>[A-Z]+-\d+) +.*$')

def values(issues, key, fields, child=''):
    values = [child + key]
    for field in fields:
        if isinstance(issues[key][field], list):
            values.append(' ,'.join(issues[key][field]))
        else:
            values.append(issues[key][field])

    return values

def subset(needle, haystack):
    if isinstance(needle, list) and isinstance(haystack, list):
        for item0, item1 in zip(needle, haystack):
            if not subset(item0, item1):
                return False
    elif isinstance(needle, dict) and isinstance(haystack, dict):
        for item in needle:
            if not subset(needle[item], haystack[item]):
                return False
    elif isinstance(needle, str) and isinstance(haystack, unicode):
        return needle.replace('\r', '') == haystack.replace('\r', '')
    else:
        return needle == haystack

    return True

class Gira(cli.Cli):
    def __init__(self, server, project):
        cli.Cli.__init__(self, history=True)

        self.server = server
        self.project = project
        self.prompt = (project if project else 'gira') + '% '
        self.wrapper = textwrap.TextWrapper(width=80)

        # Configuration
        self.cfg = ConfigParser.SafeConfigParser()
        self.cfg.read(self.directory + '/gira.cfg')

        # Get a new cookie if needs be
        self.cookiepath = self.directory + '/cookie'
        if not os.path.exists(os.path.expanduser(self.cookiepath)):
            self.getcookie()

        # Arguments
        self.versionsparser.add_argument('-p', '--project')

        self.componentsparser.add_argument('-p', '--project')

        self.issuesparser.add_argument('-p', '--project')
        self.issuesparser.add_argument('-c', '--component')
        self.issuesparser.add_argument('-g', '--group',
                                       choices=['version', 'component'])
        self.issuesparser.add_argument('-v', '--version', nargs='+')
        self.issuesparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.searchparser.add_argument('jql', nargs='+')
        self.searchparser.add_argument('-m', '--maxresults', type=int,
                                       default=MAXRESULTS)

        self.useparser.add_argument('project')

        self.issueparser.add_argument('key', nargs='+')
        self.issueparser.add_argument('-e', '--edit', action='store_true')

        self.debugparser.add_argument('resource')

        # Sink for curl
        self.null = open(os.devnull, 'w')

    def getcookie(self):
        print "Getting a fresh cookie... ",
        sys.stdout.flush()
        subprocess.call(['get-cookie', '-u',
                         self.server + '/login', '-o', self.cookiepath])
        print "Done."

    def curl(self, res, method=None, data=None):
        def curl():
            # Assemble arguments
            args = ['curl', '-b', self.cookiepath]
            if method and data:
                # str(data) not good enough because JIRA is picky on which
                # quotes to use, and json does it right
                args += ['-X', method, '-d', json.dumps(data), '-H',
                         'Content-Type: application/json']
            args += [url]

            # Run curl
            proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                    stderr=self.null)
            out, _ = proc.communicate()
            if out: # PUT returns empty string
                return json.loads(out)

        # Prepare
        url = self.server + URL + res

        # Run curl and ask for a cookie if needs be
        try:
            jsonout = curl()
        except ValueError:
            self.getcookie()
            jsonout = curl()

        return jsonout

    def run_versions(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            versions = [ver['name'] for ver in self.curl(res)['versions']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        tempfhl = open(self.temp, 'w')
        for fhl in sys.stdout, tempfhl:
            for version in sorted(versions):
                print >> fhl, version
        tempfhl.close()

    def issues(self, query, group, maxresults):
        try:
            # Collect issues and their relationships
            result = self.search(query, maxresults)
            # pprint.pprint(result)
        except KeyError:
            # No matching issue
            for msg in result['errorMessages']:
                print >> sys.stderr, self.wrapper.fill(msg)
            return

        if group == 'version': versions = {}
        elif group == 'component': components = {}
        else: issues = {}

        for issue in result['issues']:
            # Key
            iss = {}

            # Fields
            fields = issue['fields']

            asn = fields['assignee']
            iss['asn'] = asn['name'] if asn else ''

            iss['components'] = [com['name'] for com in fields['components']]

            iss['versions'] = [ver['name'] for ver in fields['fixVersions']]

            rep = fields['reporter']
            iss['rep'] = rep['name'] if rep else ''

            iss['status'] = fields['status']['name']

            iss['summary'] = fields['summary'].strip()

            iss['subtasks'] = [subtask['key'] for subtask in fields['subtasks']]

            iss['parent'] = fields['parent'] if 'parent' in fields else None

            if group == 'version':
                versstr = repr(iss['versions'])
                if versstr in versions:
                    versions[versstr]['issues'][issue['key']] = iss
                else:
                    versions[versstr] = {'versions': iss['versions'],
                                         'issues': {issue['key']: iss}}
            elif group == 'component':
                compstr = repr(iss['components'])
                if compstr in components:
                    components[compstr]['issues'][issue['key']] = iss
                else:
                    components[compstr] = {'components': iss['components'],
                                           'issues': {issue['key']: iss}}
            else:
                issues[issue['key']] = iss

        def table(tempfhl, rows, issues, fields):
            # Arrange issues for table
            for key in issues:
                issue = issues[key]
                subtasks = issue['subtasks']
                if not issue['parent'] or issue['parent']['key'] not in issues:
                    # Add row
                    rows.append(values(issues, key, fields))

                    if subtasks:
                        # Add subtasks
                        for subtask in subtasks[:-1]:
                            if subtask in issues:
                                rows.append(values(issues, subtask,
                                                   fields, '├─>'))
                        if subtasks[-1] in issues:
                            rows.append(values(issues, subtasks[-1],
                                               fields, '└─>'))

            # Print table
            tab.tab(rows, spacing=2,
                    maxw=[None, None, None, 5, 8, 6, 26], fhl=tempfhl)

        # Report
        tempfhl = open(self.temp, 'w')
        if group == 'version':
            for version in versions:
                # Create new table
                rows = [["KEY", "ASSIGNEE", "REPORTER", "COMPONENTS",
                         "STATUS", "SUMMARY"]]

                # Write header
                for vers in versions[version]['versions']:
                    print >> tempfhl, '# ' + vers

                # Write table
                table(tempfhl, rows, versions[version]['issues'],
                      ['asn', 'rep', 'components', 'status', 'summary'])
                print >> tempfhl
        elif group == 'component':
            for component in components:
                # Create new table
                rows = [["KEY", "ASSIGNEE", "REPORTER", "VERSIONS",
                         "STATUS", "SUMMARY"]]

                # Write header
                for comp in components[component]['components']:
                    print >> tempfhl, '# ' + comp

                # Write table
                table(tempfhl, rows, components[component]['issues'],
                      ['asn', 'rep', 'versions', 'status', 'summary'])
                print >> tempfhl
        else:
            rows = [["KEY", "ASSIGNEE", "REPORTER", "COMPONENTS",
                     "VERSIONS", "STATUS", "SUMMARY"]]
            table(tempfhl, rows, issues, ['asn', 'rep', 'components',
                                          'versions', 'status', 'summary'])
        tempfhl.close()


        # FIXME Need to find out if we need that but I'd rather we didn't
        # return issues

    def run_issues(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Get issues from version
        query = 'project = %s' % \
            (args.project if args.project else self.project)
        query += ' AND component = "%s"' % \
            args.component if args.component else ''
        query += ' AND fixVersion = "%s"' % \
            ' '.join(args.version) if args.version else ''

        issues = self.issues(query, args.group, args.maxresults)

        # Open page file in Vim
        subprocess.call(['vim', '-S', self.directory + '/issues.vimrc',
                         self.temp])
        self.wintitle()

        # Parse data from issues file
        tempvim = open(self.temp)
        issuesedit = self.parseissues(tempvim)
        tempvim.close()

        # pprint.pprint(issues)
        # pprint.pprint(issuesedit)

        # Update things
        # for key in issuesedit:
        #     if not subset(issuesedit[key], issues[key]):
        #         pprint.pprint(('/issue/' + key, {'fields': issuesedit[key]}))
        #         # out = self.curl('/issue/' + key, 'PUT',
        #         #                 {'fields': issuesedit[key]})
        #         # print(out)
        #         # if out and 'errors' in out:
        #         #     for error in out['errors']:
        #         #         msg = '%s: %s' % (error, out['errors'][error])
        #         #         print >> sys.stderr, self.wrapper.fill(msg)

    def nickname(self, name):
        try:
            return self.cfg.get('nicknames', name)
        except ConfigParser.NoOptionError:
            return name

    def search(self, jql, maxresults=50):
        return self.curl('/search?jql=%s&maxResults=%d' % \
                         (urllib.quote(jql), maxresults))

    def run_components(self, args):
        if not self.project:
            print >> sys.stderr, "Project not set"
            return

        # Query
        res = '/project/' + (args.project if args.project else self.project)
        try:
            components = [comp['name'] for comp in self.curl(res)['components']]
        except KeyError:
            print >> sys.stderr, args.project + ": No such project"
            return

        # Report
        tempfhl = open(self.temp, 'w')
        for fhl in sys.stdout, tempfhl:
            for component in sorted(components):
                print >> fhl, component
        tempfhl.close()

    def run_search(self, args):
        jql = ['"%s"' % word if ' ' in word else word for word in args.jql]
        self.issues(' '.join(jql), args.maxresults)

    def run_projects(self, args):
        projects = [[prj['name'], prj['key']] for prj in self.curl('/project')]
        projects.insert(0, ["PROJECT", "KEY"])
        tempfhl = open(self.temp, 'w')
        for fhl in sys.stdout, tempfhl:
            tab.tab(projects, fhl=fhl)
        tempfhl.close()

    def run_use(self, args):
        for project in self.curl('/project'):
            if args.project in (project['name'], project['key']):
                self.project = project['key']
                self.prompt = self.project + '% '
                break
        else:
            print >> sys.stderr, args.project + ": No such project"

    def run_issue(self, args):
        if args.edit:
            temp = tempfile.NamedTemporaryFile(prefix='issue-',
                                               dir=self.directory)
            fhl = temp
        else:
            fhl = sys.stdout

        issues = {}
        for key in args.key:
            issue = self.curl('/issue/%s?expand=transitions' % key)
            pprint.pprint(issue)
            issues[key] = issue

            self.form(fhl, issue, args.edit)

        if args.edit:
            # Open page file in Vim
            temp.flush()
            subprocess.call(['vim', '-S', self.directory + '/issue.vimrc',
                             temp.name])
            self.wintitle()

            # Parse data from issue file
            tempvim = open(temp.name)
            issuesedit = self.parseissue(tempvim)
            tempvim.close()

            for key, fields in issuesedit:
                # Update fields
                if not subset(fields['fields'], issues[key]['fields']):
                    out = self.curl('/issue/' + key, 'PUT',
                                    {'fields': fields['fields']})
                    if out and 'errors' in out:
                        for error in out['errors']:
                            msg = '%s: %s' % (error, out['errors'][error])
                            print >> sys.stderr, self.wrapper.fill(msg)

                # Add comment
                comment = fields['comment']
                if comment:
                    out = self.curl('/issue/%s/comment' % key, 'POST',
                                    {'body': comment})
                    if out and 'errors' in out:
                        for error in out['errors']:
                            msg = '%s: %s' % (error, out['errors'][error])
                            print >> sys.stderr, self.wrapper.fill(msg)

                # Edit comments
                comments = issues[key]['fields']['comment']['comments']
                for i, comment in enumerate(fields['comments']):
                    if not subset(comment, comments[i]):
                        cid = comments[i]['id']
                        out = self.curl('/issue/%s/comment/%s' % (key, cid),
                                        'PUT', {'body': comment})
                        # FIXME Refactor error printing (maybe in curl() itself)
                        if out and 'errors' in out:
                            for error in out['errors']:
                                msg = '%s: %s' % (error, out['errors'][error])
                                print >> sys.stderr, self.wrapper.fill(msg)

                # Perform transition
                for transition in issues[key]['transitions']:
                    # No real need to check if any change is needed since
                    # states and transitions have different names even if
                    # they relate to each other and this will cause this
                    # test to fail:
                    if fields['transition'] == transition['name']:
                        out = self.curl('/issue/%s/transitions' % key, 'POST',
                                        {'transition': transition['id']})
                        if out and 'errors' in out:
                            for error in out['errors']:
                                msg = '%s: %s' % (error, out['errors'][error])
                                print >> sys.stderr, self.wrapper.fill(msg)
                        break
        temp.close()

    def parseissue(self, temp):
        # A list of (key, {}) rather than a dictionary keyed on the issue
        # key so we can issues with the same key, as when we create many in
        # one go (e.g. literally 'AA-???').
        issues = [] 

        for line in temp:
            # Parse line
            match = REHEAD.match(line[:-1])
            if match:
                issue = {'fields': {}, 'comment': '', 'comments': [],
                         'transition': {}}
                fields = issue['fields']

                key = match.group('key')
                fields['project'] = {'key': match.group('proj')}
                summary = match.group('summary')

                issues.append((key, issue))
                fields['summary'] = summary
                state = None
                continue

            match = RETYPE.match(line[:-1])
            if match:
                fields['issuetype'] = {'name': match.group('type').strip()}
                issue['transition'] = match.group('stat')
                continue

            match = REPRIO.match(line[:-1])
            if match:
                fields['priority'] = {'name': match.group('prio').strip()}
                continue

            match = RECOMP.match(line[:-1])
            if match and line[:-1]: # But don't eat empty lines
                component = match.group('comp')
                if component:
                    if 'components' in fields:
                        components = fields['components']
                        components.append({'name': component.strip()})
                    else:
                        fields['components'] = [{'name': component.strip()}]

                version = match.group('ver')
                if version:
                    if 'fixVersions' in fields:
                        versions = fields['fixVersions']
                        versions.append({'name': version.strip()})
                    else:
                        fields['fixVersions'] = \
                            [{'name': version.strip()}]
                continue

            match = RECREA.match(line[:-1])
            if match:
                # Let's not touch dates for now
                fields['security'] = {'name': match.group('sec').strip()}
                continue

            match = REUPDA.match(line[:-1])
            if match:
                # Let's not touch dates for now
                asn = match.group('asn').strip()
                fields['assignee'] = {'name': asn} if asn else None
                continue

            match = RERESO.match(line[:-1])
            if match:
                # Let's not touch dates for now
                rep = match.group('rep').strip()
                fields['reporter'] = {'name': rep} if rep else None
                continue

            if line[:-1] == 'Description:':
                fields['description'] = ''
                state = DESC
                continue

            if RECOMM.match(line[:-1]):
                state = OLDCOMM

                # Strip last old comment since we know we won't have another one
                if issue['comments']:
                    issue['comments'][-1]['body'] = \
                        issue['comments'][-1]['body'][:-2]

                issue['comments'].append({'body': ''})
                continue

            if line[:-1] == 'New Comment?':
                if 'description' in fields:
                    fields['description'] = fields['description'][:-2]

                # Strip last old comment since we know we won't have another one
                if issue['comments']:
                    issue['comments'][-1]['body'] = \
                        issue['comments'][-1]['body'][:-2]

                state = COMM
                continue

            if REFOOT.match(line[:-1]):
                issue['comment'] = issue['comment'].strip()
                state = None
                continue

            # Handle state
            if state == DESC:
                fields['description'] += line
            elif state == COMM:
                issue['comment'] += line
            elif state == OLDCOMM:
                issue['comments'][-1]['body'] += line

        return issues

    def parseissues(self, temp):
        issues = {}
        for line in temp:
            match = RELINE.match(line)
            if match:
                if match.group('child'):
                    issues[match.group('key')] = \
                        {'parent':
                            {'fields':
                                {'issuetype': {'name': 'Technical Task'}},
                             'key': lastparent}}

                    # fields = {'key': match.group('key')}
                    # issues[lastparent]['subtasks'].append(fields)
                else:
                    issues[match.group('key')] = {'parent': None}
                    lastparent = match.group('key')

                    # issues[lastparent] = {'subtasks': []}

        return issues

    def form(self, fhl, issue, edit):
        fields = issue['fields']
        transs = [trans['name'] for trans in issue['transitions']]

        # Header
        print >> fhl, ">>> %s/%s %s" % (fields['project']['name'],
                                        issue['key'],
                                        fields['summary'])

        # Type and status
        if edit:
            fmt = "Type:       {0:%d} Status:     {1} # {2}" % WIDTH
            print >> fhl, fmt.format(fields['issuetype']['name'],
                                     fields['status']['name'],
                                     ', '.join(transs))
        else:
            fmt = "Type:       {0:%d} Status:     {1}" % WIDTH
            print >> fhl, fmt.format(fields['issuetype']['name'],
                                     fields['status']['name'])

        # Priority and resolution
        priority = fields['priority']
        resolution = fields['resolution']
        fmt = "Priority:   {0:%d} Resolution: {1}" % WIDTH
        print >> fhl, fmt.format(priority['name'] if priority else '',
                                 resolution['name'] if resolution else '')

        # Components and versions)
        compvers = enumerate(itertools.izip_longest(fields['components'],
                                                    fields['fixVersions']))
        for i, (component, version) in compvers:
            if component and version:
                fmt = "Component:  {0:%d} Version:    {1}" % WIDTH
                values = (component['name'], version['name'])
            elif component:
                fmt = "Component:  {0:%d}" % WIDTH
                values = (component['name'],)
            elif version:
                values = ('', version['name'],)
                fmt = "            {0:%d} Version:    {1}" % WIDTH
            print >> fhl, fmt.format(*values)

        # Creation date and security
        fmt =  "Created:    {0:%d} Security:   {1}" % WIDTH
        print >> fhl, fmt.format(fields['created'][:10],
                                 fields['security']['name'])

        # Update date and assignee
        asn = fields['assignee']
        asn = asn['name'] if asn else ''
        fmt =  "Updated:    {0:%d} Assignee:   {1}" % WIDTH
        print >> fhl, fmt.format(fields['updated'][:10], asn)

        # Resolution date and reporter
        resdate = fields['resolutiondate']
        fmt =  "Resolved:   {0:%d} Reporter:   {1}" % WIDTH
        print >> fhl, \
            fmt.format(resdate[:10] if resdate else '',
                       fields['reporter']['name'])

        # Description
        print >> fhl
        print >> fhl, "Description:"
        if fields['description']:
            print >> fhl, fields['description'].replace('\r', '')

        # Comments
        if fields['comment']['comments']:
            for i, comment in enumerate(fields['comment']['comments']):
                print >> fhl
                print >> fhl, "Comment from %s, %s:" % \
                    (comment['author']['name'], comment['updated'][:10])
                print >> fhl, comment['body'].replace('\r', '')

        if edit:
            print >> fhl
            print >> fhl, "New Comment?"
            print >> fhl

        # Footer
        print >> fhl, "<<< %s/%s %s" % (fields['project']['name'],
                                        issue['key'],
                                        fields['summary'])
        print >> fhl

    def run_create(self, args):
        # Write form
        temp = tempfile.NamedTemporaryFile(prefix='issue-', dir=self.directory)
        issue = {'fields': {'assignee': {'name': ''},
                            'comment': {'comments': []},
                            'components': [{'name': '...'}],
                            'created': 'Now',
                            'description': '...',
                            'fixVersions': [{'name': '...'}],
                            'issuetype': {'name': '...'},
                            'priority': {'name': '...'},
                            'project': {'name': self.project},
                            'reporter': {'name': os.environ['USER']},
                            'resolution': {'name': ''},
                            'resolutiondate': '',
                            'security': {'name': 'Internal Data'},
                            'status': {'name': 'Open'},
                            'summary': '...',
                            'updated': 'Now'},
                 'key': self.project + '-???',
                 'transitions': []}
        self.form(temp, issue, False)

        # Open page file in Vim
        temp.flush()
        subprocess.call(['vim', '-S', self.directory + '/issue.vimrc',
                         temp.name])
        self.wintitle()

        # Parse date from page file
        tempvim = open(temp.name)
        issuesedit = self.parseissue(tempvim)
        tempvim.close()

        # Write issue data to JIRA
        for key, fields in issuesedit:
            out = self.curl('/issue', 'POST', {'fields': fields['fields']})
            if out and 'errors' in out:
                for error in out['errors']:
                    msg = '%s: %s' % (error, out['errors'][error])
                    print >> sys.stderr, self.wrapper.fill(msg)

    def run_debug(self, args):
        jsonoutput = self.curl(args.resource)
        tempfhl = open(self.temp, 'w')
        tempfhl.write(pprint.pformat(jsonoutput))
        tempfhl.close()
        pprint.pprint(jsonoutput)

def main():
    # Arguments
    p = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    p.add_argument('-s', '--server', default='https://example.net/jira')
    p.add_argument('project', nargs='?')
    args = p.parse_args()

    # CLI
    Gira(args.server, args.project).loop()

if __name__ == '__main__':
    main()
